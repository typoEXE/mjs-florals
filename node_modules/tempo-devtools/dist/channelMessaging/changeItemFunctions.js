"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateCodebaseIds = exports.applyChangeItemToDocument = exports.TEMPORARY_STYLING_CLASS_NAME = exports.ADD_CLASS_INSTANT_UPDATE_QUEUE = exports.ADD_JSX_PREFIX = exports.DUPLICATE_PLACEHOLDER_PREFIX = exports.WRAP_IN_DIV_PLACEHOLDER_CODEBASE_ID = void 0;
const jquery_1 = __importDefault(require("jquery"));
const identifierUtils_1 = require("./identifierUtils");
const changeLedgerTypes_1 = require("./changeLedgerTypes");
const constantsAndTypes_1 = require("./constantsAndTypes");
const cssRuleUtils_1 = require("./cssRuleUtils");
const sessionStorageUtils_1 = require("./sessionStorageUtils");
const tempoElement_1 = require("./tempoElement");
const uuid_1 = require("uuid");
// These constants match what tempo-api has
exports.WRAP_IN_DIV_PLACEHOLDER_CODEBASE_ID = 'tempo-wrap-in-div-placeholder';
exports.DUPLICATE_PLACEHOLDER_PREFIX = 'tempo-duplicate-placeholder-';
exports.ADD_JSX_PREFIX = 'tempo-add-jsx-placeholder-';
// Stored in memory storage, used to keep track of some possible add class instant
// updates that need to be re-applied after a hot reload
// (e.g. when the additional) instant updates happened during flushing
exports.ADD_CLASS_INSTANT_UPDATE_QUEUE = 'ADD_CLASS_INSTANT_UPDATE_QUEUE';
exports.TEMPORARY_STYLING_CLASS_NAME = 'arb89-temp-styling';
const getTopLevelCodebaseIdForComponent = (componentId) => {
    let topLevelCodebaseId = null;
    let minNumberParents = Infinity;
    (0, jquery_1.default)(`.component-${componentId}`).each((index, element) => {
        if ((0, jquery_1.default)(element).parents().length < minNumberParents) {
            minNumberParents = (0, jquery_1.default)(element).parents().length;
            topLevelCodebaseId = (0, identifierUtils_1.getCodebaseIdFromNode)(element);
        }
    });
    return topLevelCodebaseId;
};
const makeid = (length) => {
    let result = '';
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    const charactersLength = characters.length;
    let counter = 0;
    while (counter < length) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
        counter += 1;
    }
    return result;
};
const addOrEditCSSRule = (selector, rules, id) => {
    var styleEl = document.createElement('style');
    if (id) {
        const existingElement = document.getElementById(id);
        if (existingElement) {
            existingElement.remove();
        }
        styleEl.id = id;
    }
    // Append <style> element to <head>
    document.head.appendChild(styleEl);
    var styleSheet = styleEl.sheet;
    if (styleSheet.insertRule) {
        // All browsers, except IE before version 9
        styleSheet.insertRule(selector + '{' + rules + '}', styleSheet.cssRules.length);
    }
    else if (styleSheet.addRule) {
        // IE before version 9
        styleSheet.addRule(selector, rules, styleSheet.rules.length);
    }
};
const applyChangeItemToDocument = (parentPort, storyboardId, plainChangeItem) => {
    var _a;
    if (!plainChangeItem || !plainChangeItem.type) {
        return { sendNewNavTree: false, instantUpdateSuccessful: false };
    }
    const changeItem = (0, changeLedgerTypes_1.reconstructChangeLedgerClass)(plainChangeItem);
    let extraInstantUpdateData = {};
    let instantUpdateSuccessful = false;
    // The display: none rule is needed for a lot of instant updates, so create it if it doesn't exist
    if (!document.getElementById(identifierUtils_1.TEMPO_DISPLAY_NONE_UNTIL_REFRESH_CLASS)) {
        addOrEditCSSRule(`.${identifierUtils_1.TEMPO_DISPLAY_NONE_UNTIL_REFRESH_CLASS}`, 'display: none !important', identifierUtils_1.TEMPO_DISPLAY_NONE_UNTIL_REFRESH_CLASS);
    }
    let sendNewNavTree = false;
    if (changeItem.type === changeLedgerTypes_1.ChangeType.ADD_JSX) {
        const castChangeItem = changeItem;
        const changeFields = castChangeItem.changeFields;
        const newAddedIds = [];
        if (changeFields.htmlForInstantUpdate) {
            const elementToAdd = (0, jquery_1.default)(changeFields.htmlForInstantUpdate);
            elementToAdd.attr(identifierUtils_1.TEMPO_DELETE_AFTER_REFRESH, 'true');
            elementToAdd.attr(identifierUtils_1.TEMPO_INSTANT_UPDATE, 'true'); // So that the DOM tree refresh doesn't get triggered
            elementToAdd.attr(identifierUtils_1.TEMPO_OUTLINE_UNTIL_REFESH, 'true');
            const ID_FOR_ELEMENT = `${exports.ADD_JSX_PREFIX}${(0, uuid_1.v4)()}`;
            elementToAdd.attr(identifierUtils_1.TEMPO_ELEMENT_ID, ID_FOR_ELEMENT);
            elementToAdd.addClass(ID_FOR_ELEMENT);
            newAddedIds.push(ID_FOR_ELEMENT);
            (0, jquery_1.default)(`.${changeFields.codebaseIdToAddTo}`).each((index, item) => {
                if (changeFields.afterCodebaseId) {
                    const afterElement = (0, jquery_1.default)(`.${changeFields.afterCodebaseId}`);
                    if (!(afterElement === null || afterElement === void 0 ? void 0 : afterElement.length)) {
                        return;
                    }
                    elementToAdd.insertAfter(afterElement.first());
                }
                else if (changeFields.beforeCodebaseId) {
                    const beforeElement = (0, jquery_1.default)(`.${changeFields.beforeCodebaseId}`);
                    if (!(beforeElement === null || beforeElement === void 0 ? void 0 : beforeElement.length)) {
                        return;
                    }
                    elementToAdd.insertBefore(beforeElement.first());
                }
                else {
                    (0, jquery_1.default)(item).append(elementToAdd);
                }
                sendNewNavTree = true;
                instantUpdateSuccessful = true;
            });
        }
        extraInstantUpdateData['newAddedIds'] = newAddedIds;
    }
    else if (changeItem.type === changeLedgerTypes_1.ChangeType.MOVE_JSX) {
        const castChangeItem = changeItem;
        // Find each element that matches the jsxCodebaseId
        const sourceElements = [];
        // See if direct matches work first
        if ((0, jquery_1.default)(`.${castChangeItem.changeFields.codebaseIdToMove}`).length > 0) {
            (0, jquery_1.default)(`.${castChangeItem.changeFields.codebaseIdToMove}`).each((index, element) => {
                sourceElements.push((0, jquery_1.default)(element));
            });
        }
        else {
            // Try to find it by the component ID
            let topLevelCodebaseId = getTopLevelCodebaseIdForComponent(castChangeItem.changeFields.codebaseIdToMove || '');
            if (topLevelCodebaseId) {
                (0, jquery_1.default)(`.${topLevelCodebaseId}`).each((index, element) => {
                    sourceElements.push((0, jquery_1.default)(element));
                });
            }
        }
        // If the container is a component, drop into the codebaseId of the top-most child div
        let containerCodebaseId = getTopLevelCodebaseIdForComponent(castChangeItem.changeFields.codebaseIdToMoveTo || '') || castChangeItem.changeFields.codebaseIdToMoveTo;
        // For each source element, find the new matching parent element
        const newParentElements = [];
        sourceElements.forEach((element) => {
            let newParentElement = null;
            // For each parent, try to see if it either matches or contains the new parent
            let parentElement = element.parent();
            while (parentElement.length) {
                // If the parent directly matches, this is it
                if (parentElement.hasClass(containerCodebaseId)) {
                    newParentElement = parentElement;
                    break;
                }
                // Check children that match the codebase ID to drop into
                const matchingChildren = parentElement.find(`.${containerCodebaseId}`);
                if (matchingChildren.length) {
                    // TODO: What if this matches more than one?
                    newParentElement = matchingChildren.first();
                    break;
                }
                parentElement = parentElement.parent();
            }
            if (!newParentElement) {
                newParentElements.push(null);
                return;
            }
            newParentElements.push(newParentElement);
        });
        // For each child/parentElement pair, move the child to the new parent
        sourceElements.forEach((element, index) => {
            const newParentElement = newParentElements[index];
            if (!newParentElement.length) {
                console.log('Could not find new parent element for instant update');
                return;
            }
            sendNewNavTree = true;
            instantUpdateSuccessful = true;
            element.attr(identifierUtils_1.TEMPO_INSTANT_UPDATE, 'true');
            // If the parent hasn't changed, just move it, otherwise clone it and create a new one in the new spot
            let useClone = !newParentElement.is(element.parent());
            // So that nextjs hot reloading works, simply hide the element and clone it into the new spot
            let cloneElement;
            if (useClone) {
                cloneElement = element.clone();
                cloneElement.attr(identifierUtils_1.TEMPO_DELETE_AFTER_REFRESH, 'true');
                element.addClass(identifierUtils_1.TEMPO_DISPLAY_NONE_UNTIL_REFRESH_CLASS);
                element.attr(identifierUtils_1.TEMPO_DO_NOT_SHOW_IN_NAV_UNTIL_REFRESH, 'true');
            }
            if (castChangeItem.changeFields.afterCodebaseId) {
                const afterIdToUse = getTopLevelCodebaseIdForComponent(castChangeItem.changeFields.afterCodebaseId) || castChangeItem.changeFields.afterCodebaseId;
                const afterElement = newParentElement.children(`.${afterIdToUse}`);
                if (afterElement.length) {
                    if (useClone && cloneElement) {
                        cloneElement.insertAfter(afterElement.first());
                    }
                    else {
                        element.insertAfter(afterElement.first());
                    }
                    return;
                }
            }
            if (castChangeItem.changeFields.beforeCodebaseId) {
                const beforeIdToUse = getTopLevelCodebaseIdForComponent(castChangeItem.changeFields.beforeCodebaseId) || castChangeItem.changeFields.beforeCodebaseId;
                const beforeElement = newParentElement.children(`.${beforeIdToUse}`);
                if (beforeElement.length) {
                    if (useClone && cloneElement) {
                        cloneElement.insertBefore(beforeElement.first());
                    }
                    else {
                        element.insertBefore(beforeElement.first());
                    }
                    return;
                }
            }
            if (useClone && cloneElement) {
                cloneElement.appendTo(newParentElement);
            }
            else {
                element.appendTo(newParentElement);
            }
        });
    }
    else if (changeItem.type === changeLedgerTypes_1.ChangeType.REMOVE_JSX) {
        const castChangeItem = changeItem;
        const parentToElementKeysRemoved = {};
        castChangeItem.changeFields.codebaseIdsToRemove.forEach((codebaseId) => {
            // See if direct matches work first
            let codebaseIdToRemove;
            if ((0, jquery_1.default)(`.${codebaseId}`).length > 0) {
                codebaseIdToRemove = codebaseId;
            }
            else {
                // Try to find it by the component ID
                let topLevelCodebaseId = getTopLevelCodebaseIdForComponent(codebaseId || '');
                if (!topLevelCodebaseId) {
                    console.log('Could not find component element for instant update');
                    return false;
                }
                codebaseIdToRemove = topLevelCodebaseId;
            }
            // For each item that is removed, save the inner HTML in case it gets deleted and we want to undo
            (0, jquery_1.default)(`.${codebaseIdToRemove}`).each((index, item) => {
                const elementKeyRemoved = (0, identifierUtils_1.getElementKeyFromNode)(item);
                const parentElementKey = (0, identifierUtils_1.getElementKeyFromNode)(item.parentElement);
                if (elementKeyRemoved && parentElementKey) {
                    if (!parentToElementKeysRemoved[parentElementKey]) {
                        parentToElementKeysRemoved[parentElementKey] = [];
                    }
                    parentToElementKeysRemoved[parentElementKey].push({
                        outerHTML: item.outerHTML,
                        elementKeyRemoved,
                    });
                }
                item.classList.add(identifierUtils_1.TEMPO_DISPLAY_NONE_UNTIL_REFRESH_CLASS);
                item.setAttribute(identifierUtils_1.TEMPO_DO_NOT_SHOW_IN_NAV_UNTIL_REFRESH, 'true');
                sendNewNavTree = true;
                instantUpdateSuccessful = true;
            });
        });
        extraInstantUpdateData.parentToElementKeysRemoved =
            parentToElementKeysRemoved;
    }
    else if (changeItem.type === changeLedgerTypes_1.ChangeType.ADD_CLASS ||
        changeItem.type === changeLedgerTypes_1.ChangeType.STYLING) {
        let className, cssEquivalent, codebaseIdToAddClass, temporaryClass, codebaseClassName, modifiers;
        if (changeItem.type === changeLedgerTypes_1.ChangeType.ADD_CLASS) {
            const castChangeItem = changeItem;
            codebaseClassName = castChangeItem.changeFields.className;
            className = castChangeItem.changeFields.className;
            cssEquivalent = castChangeItem.changeFields.cssEquivalent;
            codebaseIdToAddClass = castChangeItem.changeFields.codebaseIdToAddClass;
            temporaryClass = castChangeItem.changeFields.temporaryOnly;
            modifiers = castChangeItem.changeFields.modifiers;
            if (temporaryClass) {
                className = exports.TEMPORARY_STYLING_CLASS_NAME;
            }
        }
        else {
            // As of March 6, 2024 we only support tailwind STYLING changes, so treat them as adding a class
            const castChangeItem = changeItem.changeFields;
            className = '';
            cssEquivalent = Object.keys(castChangeItem.stylingChanges)
                .map((key) => {
                if (castChangeItem.stylingChanges[key] === constantsAndTypes_1.DELETE_STYLE_CONSTANT) {
                    return `${(0, cssRuleUtils_1.camelToSnakeCase)(key)}: unset !important;`;
                }
                return `${(0, cssRuleUtils_1.camelToSnakeCase)(key)}: ${castChangeItem.stylingChanges[key]};`;
            })
                .join('');
            codebaseIdToAddClass = castChangeItem.codebaseId;
            modifiers = castChangeItem.modifiers;
        }
        const SAFE_CLASSNAME_REGEX = /[^A-Za-z0-9_-]/g;
        // Escape any custom classes
        let classToAdd = (className || '')
            .replace(SAFE_CLASSNAME_REGEX, '-') // Replace any non-alphanumeric characters with '-'
            .replace(/^\d/, '-$&'); // If the class starts with a digit, prepend with '-'
        // Instead of adding the class name, generate a new class and set the
        // css equivalent values inside it
        // This class will be deleted after a hot reload
        // Note - for temporary classes we want to explicitly use the same class
        if (cssEquivalent && !temporaryClass) {
            const msSinceJan1 = Date.now() - 1704067200000;
            classToAdd = `${identifierUtils_1.TEMPO_INSTANT_UPDATE_STYLING_PREFIX}${msSinceJan1}-${classToAdd}`;
        }
        if (classToAdd) {
            if (!temporaryClass) {
                // Clear the temporary class on this element if it has it
                (0, jquery_1.default)(`.${codebaseIdToAddClass}`).removeClass(exports.TEMPORARY_STYLING_CLASS_NAME);
            }
            if (cssEquivalent) {
                if (modifiers && modifiers.length > 0) {
                    const CSS_PSEUDO_MODIFIERS = [
                        'hover',
                        'required',
                        'focus',
                        'active',
                        'invalid',
                        'disabled',
                    ];
                    const pseudoModifiers = modifiers.filter((modifier) => CSS_PSEUDO_MODIFIERS.includes(modifier));
                    const pseudoModifiersSuffix = pseudoModifiers.join(':');
                    if (pseudoModifiers.length > 0) {
                        const modifierClass = `${classToAdd}:${pseudoModifiersSuffix}`;
                        addOrEditCSSRule(`.${modifierClass}`, cssEquivalent, modifierClass);
                    }
                    else {
                        addOrEditCSSRule(`.${classToAdd}`, cssEquivalent, classToAdd);
                    }
                    const forceClasses = modifiers
                        .map((modifier) => `.tempo-force-${modifier}`)
                        .join('');
                    const instantUpdateForForceClass = `${classToAdd}${forceClasses}`;
                    addOrEditCSSRule(`.${instantUpdateForForceClass}`, cssEquivalent, instantUpdateForForceClass);
                }
                else {
                    addOrEditCSSRule(`.${classToAdd}`, cssEquivalent, classToAdd);
                }
            }
            const currentAddClassValues = (0, sessionStorageUtils_1.getMemoryStorageItem)(exports.ADD_CLASS_INSTANT_UPDATE_QUEUE) || [];
            // See if direct matches work first
            if ((0, jquery_1.default)(`.${codebaseIdToAddClass}`).length > 0) {
                (0, jquery_1.default)(`.${codebaseIdToAddClass}`).addClass(classToAdd);
                instantUpdateSuccessful = true;
                currentAddClassValues.push({
                    codebaseId: codebaseIdToAddClass,
                    className: classToAdd,
                });
            }
            else {
                // Try to find it by the component ID
                let topLevelCodebaseId = getTopLevelCodebaseIdForComponent(codebaseIdToAddClass || '');
                if (topLevelCodebaseId && (0, jquery_1.default)(`.${topLevelCodebaseId}`).length > 0) {
                    instantUpdateSuccessful = true;
                    (0, jquery_1.default)(`.${topLevelCodebaseId}`).addClass(classToAdd);
                    currentAddClassValues.push({
                        codebaseId: topLevelCodebaseId,
                        className: classToAdd,
                    });
                }
            }
            (0, sessionStorageUtils_1.setMemoryStorageItem)(exports.ADD_CLASS_INSTANT_UPDATE_QUEUE, currentAddClassValues);
            extraInstantUpdateData.addedClass = classToAdd;
            extraInstantUpdateData.codebaseAddedClass = codebaseClassName;
        }
    }
    else if (changeItem.type === changeLedgerTypes_1.ChangeType.REMOVE_CLASS) {
        const removeClassChangeFields = changeItem.changeFields;
        // See if direct matches work first
        if ((0, jquery_1.default)(`.${removeClassChangeFields.codebaseIdToRemoveClass}`).length > 0) {
            (0, jquery_1.default)(`.${removeClassChangeFields.codebaseIdToRemoveClass}`).removeClass(removeClassChangeFields.className);
            instantUpdateSuccessful = true;
        }
        else {
            // Try to find it by the component ID
            let topLevelCodebaseId = getTopLevelCodebaseIdForComponent(removeClassChangeFields.codebaseIdToRemoveClass || '');
            if (topLevelCodebaseId && (0, jquery_1.default)(`.${topLevelCodebaseId}`).length > 0) {
                instantUpdateSuccessful = true;
                (0, jquery_1.default)(`.${topLevelCodebaseId}`).removeClass(removeClassChangeFields.className);
            }
        }
    }
    else if (changeItem.type === changeLedgerTypes_1.ChangeType.WRAP_DIV) {
        const changeFields = changeItem.changeFields;
        const codebaseIdsToWrap = changeFields.codebaseIdsToWrap;
        const firstCodebaseId = codebaseIdsToWrap[0];
        // We assume the other codebase IDs are siblings of this codebase ID, so we
        // find each instance of the first one and include the other items that match in it
        // If the other items aren't all found, we do not wrap and let hot reload handle it
        (0, jquery_1.default)(`.${firstCodebaseId}`).each((index, item) => {
            const otherCodebaseIds = codebaseIdsToWrap.slice(1);
            // For each codebase ID in otherCodebaseIds, retrieve the element that is a sibling of item
            const siblings = (0, jquery_1.default)(item).siblings();
            const allItemsToAddToNewDiv = [item];
            let earliestItem = item;
            let earliestIndex = (0, jquery_1.default)(item).index();
            otherCodebaseIds.forEach((codebaseId) => {
                const foundSibling = siblings.filter(`.${codebaseId}`).get(0);
                if (foundSibling) {
                    allItemsToAddToNewDiv.push(foundSibling);
                    const index = (0, jquery_1.default)(foundSibling).index();
                    if (index < earliestIndex) {
                        earliestItem = foundSibling;
                        earliestIndex = index;
                    }
                }
            });
            // TODO: What to do if they all can't be found?
            if (allItemsToAddToNewDiv.length !== codebaseIdsToWrap.length) {
                // For now, just add the ones that were found
            }
            // Create a div with a clone of the item, while hiding the item
            // When the hot reload happens the clone gets deleted and the item is shown again
            const newDiv = document.createElement('div');
            newDiv.className = exports.WRAP_IN_DIV_PLACEHOLDER_CODEBASE_ID;
            newDiv.setAttribute(identifierUtils_1.TEMPO_INSTANT_UPDATE, 'true'); // So that the DOM tree refresh doesn't get triggered
            newDiv.setAttribute('tempoelementid', exports.WRAP_IN_DIV_PLACEHOLDER_CODEBASE_ID);
            newDiv.setAttribute(identifierUtils_1.TEMPO_DELETE_AFTER_REFRESH, 'true');
            allItemsToAddToNewDiv.forEach((elem) => {
                newDiv.appendChild(elem.cloneNode(true));
                elem.classList.add(identifierUtils_1.TEMPO_DISPLAY_NONE_UNTIL_REFRESH_CLASS);
                elem.setAttribute(identifierUtils_1.TEMPO_DO_NOT_SHOW_IN_NAV_UNTIL_REFRESH, 'true');
            });
            // Insert the new div right before the first item
            earliestItem.insertAdjacentElement('beforebegin', newDiv);
            sendNewNavTree = true;
            instantUpdateSuccessful = true;
        });
    }
    else if (changeItem.type === changeLedgerTypes_1.ChangeType.DUPLICATE) {
        const changeFileds = changeItem.changeFields;
        const codebaseIdsToDuplicate = changeFileds.codebaseIdsToDuplicate;
        codebaseIdsToDuplicate.forEach((codebaseIdToDuplicate) => {
            (0, jquery_1.default)(`.${codebaseIdToDuplicate}`).each((index, item) => {
                const clonedNode = item.cloneNode(true);
                clonedNode.setAttribute(identifierUtils_1.TEMPO_DELETE_AFTER_REFRESH, 'true');
                clonedNode.setAttribute(identifierUtils_1.TEMPO_INSTANT_UPDATE, 'true'); // So that the DOM tree refresh doesn't get triggered
                // Set up all the correct duplicated codebase IDs
                clonedNode.setAttribute('tempoelementid', `${exports.DUPLICATE_PLACEHOLDER_PREFIX}${codebaseIdToDuplicate}`);
                clonedNode.classList.add(exports.DUPLICATE_PLACEHOLDER_PREFIX + codebaseIdToDuplicate);
                clonedNode.classList.remove(codebaseIdToDuplicate);
                let children = Array.from(clonedNode.children);
                while (children.length) {
                    const child = children.pop();
                    if (!child) {
                        continue;
                    }
                    const codebaseId = child.getAttribute('tempoelementid');
                    if (!codebaseId) {
                        continue;
                    }
                    child.setAttribute('tempoelementid', `${exports.DUPLICATE_PLACEHOLDER_PREFIX}${codebaseId}`);
                    child.classList.remove(codebaseId);
                    child.classList.add(exports.DUPLICATE_PLACEHOLDER_PREFIX + codebaseId);
                    child.setAttribute(identifierUtils_1.TEMPO_INSTANT_UPDATE, 'true');
                    children.push(...Array.from(child.children));
                }
                // Add the clones node right after the found node
                item.insertAdjacentElement('afterend', clonedNode);
                sendNewNavTree = true;
                instantUpdateSuccessful = true;
            });
        });
    }
    else if (changeItem.type === changeLedgerTypes_1.ChangeType.CHANGE_TAG) {
        const changeFields = changeItem.changeFields;
        (0, jquery_1.default)(`.${changeFields.codebaseIdToChange}`).each((index, item) => {
            const $newElement = (0, jquery_1.default)('<' + changeFields.newTagName + '></' + changeFields.newTagName + '>');
            $newElement.attr(identifierUtils_1.TEMPO_INSTANT_UPDATE, 'true'); // So that the DOM tree refresh doesn't get triggered
            $newElement.attr(identifierUtils_1.TEMPO_DELETE_AFTER_REFRESH, 'true');
            const $item = (0, jquery_1.default)(item);
            // Copy all attributes from the original element to the new element
            jquery_1.default.each($item[0].attributes, function () {
                $newElement.attr(this.name, this.value);
            });
            $item.contents().clone(true, true).appendTo($newElement);
            // Add right before the cloned item so the unique path stays the same
            $item.before($newElement);
            // Hide the original item
            $item.addClass(identifierUtils_1.TEMPO_DISPLAY_NONE_UNTIL_REFRESH_CLASS);
            $item.attr(identifierUtils_1.TEMPO_DO_NOT_SHOW_IN_NAV_UNTIL_REFRESH, 'true');
            sendNewNavTree = true;
            instantUpdateSuccessful = true;
        });
    }
    else if (changeItem.type === changeLedgerTypes_1.ChangeType.UNDO) {
        const { sendNewNavTree: _sendNewNavTree, instantUpdateSuccessful: _instantUpdateSuccessful, } = applyUndoChangeItemToDocument(parentPort, changeItem);
        sendNewNavTree = _sendNewNavTree;
        instantUpdateSuccessful = _instantUpdateSuccessful;
    }
    else if (changeItem.type === changeLedgerTypes_1.ChangeType.REDO) {
        const changeFields = changeItem.changeFields;
        const changeToRedo = changeFields.changeToRedo;
        if (changeLedgerTypes_1.CHANGE_TYPES_WITH_INSTANT_UNDO.includes(changeToRedo.type)) {
            const { sendNewNavTree: _sendNewNavTree, instantUpdateSuccessful: _instantUpdateSuccessful, } = (0, exports.applyChangeItemToDocument)(parentPort, storyboardId, changeToRedo);
            sendNewNavTree = _sendNewNavTree;
            instantUpdateSuccessful = _instantUpdateSuccessful;
            if (changeToRedo.prevIdToNewIdMap) {
                (0, exports.updateCodebaseIds)(parentPort, changeToRedo.prevIdToNewIdMap, true);
            }
        }
    }
    // Immediately set the new selected element keys to prevent any delay in the outlines updating
    let elementKeyToSelectAfterInstantUpdate = changeItem.getElementKeyToSelectAfterInstantUpdate();
    let elementKeysToMultiselectAfterInstantUpdate = changeItem.getElementKeysToMultiselectAfterInstantUpdate();
    if (changeItem.type === changeLedgerTypes_1.ChangeType.UNDO) {
        elementKeyToSelectAfterInstantUpdate = changeItem.changeFields.changeToUndo.getElementKeyToSelectAfterUndoInstantUpdate();
        elementKeysToMultiselectAfterInstantUpdate = changeItem.changeFields.changeToUndo.getElementKeysToMultiselectAfterUndoInstantUpdate();
    }
    if (elementKeyToSelectAfterInstantUpdate !== undefined) {
        (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.SELECTED_ELEMENT_KEY, elementKeyToSelectAfterInstantUpdate);
        parentPort.postMessage({
            id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.SELECTED_ELEMENT_KEY,
            elementKey: elementKeyToSelectAfterInstantUpdate,
            outerHTML: (_a = (0, jquery_1.default)(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${elementKeyToSelectAfterInstantUpdate}`).get(0)) === null || _a === void 0 ? void 0 : _a.outerHTML,
        });
    }
    if (elementKeysToMultiselectAfterInstantUpdate !== undefined) {
        (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.MULTI_SELECTED_ELEMENT_KEYS, elementKeysToMultiselectAfterInstantUpdate);
        parentPort.postMessage({
            id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.MULTI_SELECTED_ELEMENT_KEYS,
            elementKeys: elementKeysToMultiselectAfterInstantUpdate,
            outerHTMLs: elementKeysToMultiselectAfterInstantUpdate === null || elementKeysToMultiselectAfterInstantUpdate === void 0 ? void 0 : elementKeysToMultiselectAfterInstantUpdate.map((elementKey) => { var _a; return (_a = (0, jquery_1.default)(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${elementKey}`).get(0)) === null || _a === void 0 ? void 0 : _a.outerHTML; }),
        });
    }
    if (instantUpdateSuccessful) {
        // Delete any elements that need to be deleted after instant updates
        (0, jquery_1.default)(`*[${identifierUtils_1.TEMPO_DELETE_AFTER_INSTANT_UPDATE}=true]`).remove();
    }
    parentPort.postMessage({
        id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.INSTANT_UPDATE_DONE,
        changeItem: plainChangeItem,
        instantUpdateData: extraInstantUpdateData,
        instantUpdateSuccessful,
    });
    return { sendNewNavTree, instantUpdateSuccessful };
};
exports.applyChangeItemToDocument = applyChangeItemToDocument;
const applyUndoChangeItemToDocument = (parentPort, changeItem) => {
    const changeFields = changeItem.changeFields;
    const changeToUndo = changeFields.changeToUndo;
    if (!changeLedgerTypes_1.CHANGE_TYPES_WITH_INSTANT_UNDO.includes(changeToUndo.type)) {
        return { sendNewNavTree: false, instantUpdateSuccessful: false };
    }
    let sendNewNavTree = false;
    let instantUpdateSuccessful = false;
    // API has completed and the IDs have been updated, reverse this change
    if (changeToUndo.prevIdToNewIdMap) {
        const undoCodebaseIdChanges = {};
        Object.keys(changeToUndo.prevIdToNewIdMap).forEach((prevId) => {
            const newId = changeToUndo.prevIdToNewIdMap[prevId];
            undoCodebaseIdChanges[newId] = prevId;
        });
        // If undoing do not update the codebase IDs backwards if there are codebase IDs to set after
        // the undo instant update is done
        const selectedElementSpecifiedAfterUndo = changeToUndo.getElementKeyToSelectAfterUndoInstantUpdate() !== undefined;
        (0, exports.updateCodebaseIds)(parentPort, undoCodebaseIdChanges, !selectedElementSpecifiedAfterUndo);
    }
    // Then undo the actual change
    if (changeToUndo.type === changeLedgerTypes_1.ChangeType.REMOVE_JSX) {
        // Re-add the removed JSX
        const innerChangeFields = changeToUndo.changeFields;
        const codebaseIdsToReadd = innerChangeFields.codebaseIdsToRemove;
        // If it has been flushed, re-create the html elements from the saved inner HTML
        if (changeFields.matchingActivityFlushed) {
            const instantUpdateData = changeToUndo.getInstantUpdateData();
            const parentToElementKeysRemoved = instantUpdateData.parentToElementKeysRemoved || {};
            Object.entries(parentToElementKeysRemoved).forEach(([parentElementKey, itemsRemoved]) => {
                // Sort the removed entries in order of unique path
                const sortedItemsRemoved = Object.values(itemsRemoved).sort((a, b) => {
                    const aElementKey = tempoElement_1.TempoElement.fromKey(a.elementKeyRemoved);
                    const bElementKey = tempoElement_1.TempoElement.fromKey(b.elementKeyRemoved);
                    return aElementKey.uniquePath.localeCompare(bElementKey.uniquePath);
                });
                // Find the parent element
                const parentElement = (0, jquery_1.default)(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${parentElementKey}`).get(0);
                if (parentElement) {
                    // Add the removed elements back in order
                    sortedItemsRemoved.forEach((item) => {
                        const { elementKeyRemoved, outerHTML } = item;
                        const element = tempoElement_1.TempoElement.fromKey(elementKeyRemoved);
                        const indexInParent = Number(element.uniquePath.split('-').pop());
                        const newElementFromHtml = (0, jquery_1.default)(outerHTML).get(0);
                        // Add to the parent in the index
                        if (newElementFromHtml) {
                            newElementFromHtml.setAttribute(identifierUtils_1.TEMPO_DELETE_AFTER_REFRESH, 'true');
                            newElementFromHtml.setAttribute(identifierUtils_1.TEMPO_INSTANT_UPDATE, 'true');
                            parentElement.insertBefore(newElementFromHtml, parentElement.children[indexInParent] || null);
                            instantUpdateSuccessful = true;
                            sendNewNavTree = true;
                        }
                    });
                }
            });
        }
        else {
            // Not flushed yet so can just re-add
            codebaseIdsToReadd.forEach((codebaseIdToReadd) => {
                (0, jquery_1.default)(`.${codebaseIdToReadd}`).each((index, item) => {
                    item.classList.remove(identifierUtils_1.TEMPO_DISPLAY_NONE_UNTIL_REFRESH_CLASS);
                    item.removeAttribute(identifierUtils_1.TEMPO_DO_NOT_SHOW_IN_NAV_UNTIL_REFRESH);
                    sendNewNavTree = true;
                    instantUpdateSuccessful = true;
                });
            });
        }
    }
    else if (changeToUndo.type === changeLedgerTypes_1.ChangeType.ADD_CLASS ||
        changeToUndo.type === changeLedgerTypes_1.ChangeType.STYLING) {
        const instantUpdateData = changeToUndo.getInstantUpdateData();
        const innerChangeFields = changeToUndo.changeFields;
        const addedClass = instantUpdateData === null || instantUpdateData === void 0 ? void 0 : instantUpdateData.addedClass;
        if (addedClass) {
            (0, jquery_1.default)(`.${innerChangeFields.codebaseIdToAddClass}`).each((index, item) => {
                if ((0, jquery_1.default)(item).hasClass(addedClass)) {
                    (0, jquery_1.default)(item).removeClass(addedClass);
                    instantUpdateSuccessful = true;
                }
            });
        }
        const codebaseAddedClass = instantUpdateData === null || instantUpdateData === void 0 ? void 0 : instantUpdateData.codebaseAddedClass;
        if (codebaseAddedClass) {
            (0, jquery_1.default)(`.${innerChangeFields.codebaseIdToAddClass}`).each((index, item) => {
                if ((0, jquery_1.default)(item).hasClass(codebaseAddedClass)) {
                    (0, jquery_1.default)(item).removeClass(codebaseAddedClass);
                    instantUpdateSuccessful = true;
                }
            });
        }
    }
    else if (changeToUndo.type === changeLedgerTypes_1.ChangeType.ADD_JSX) {
        const instantUpdateData = changeToUndo.getInstantUpdateData();
        const addedIds = instantUpdateData === null || instantUpdateData === void 0 ? void 0 : instantUpdateData.addedIds;
        addedIds === null || addedIds === void 0 ? void 0 : addedIds.forEach((addedId) => {
            (0, jquery_1.default)(`.${addedId}`).remove();
            instantUpdateSuccessful = true;
        });
        sendNewNavTree = true;
    }
    return { sendNewNavTree, instantUpdateSuccessful };
};
/**
 * After a change is processed on the backend, we need to update the codebase ids in the document.
 */
const updateCodebaseIds = (parentPort, prevIdToNewIdMap, updateElementKeys) => {
    // Update codebase ids in the document
    const changes = [];
    Object.entries(prevIdToNewIdMap).forEach(([prevCodebaseId, newCodebaseId]) => {
        (0, jquery_1.default)(`.${prevCodebaseId}`).each((index, item) => {
            changes.push({
                item,
                prevCodebaseId,
                newCodebaseId,
            });
        });
    });
    // Codebase Ids can swap, so we have to apply the changes after looking all elements up
    changes.forEach((change) => {
        const $item = (0, jquery_1.default)(change.item);
        const newClass = ($item.attr('class') || '').replace(new RegExp(`${change.prevCodebaseId}`, 'g'), change.newCodebaseId);
        $item.attr('class', newClass);
        change.item.setAttribute('tempoelementid', change.newCodebaseId);
    });
    if (!updateElementKeys) {
        return Boolean(changes.length);
    }
    const keysToCheck = [
        {
            key: sessionStorageUtils_1.SELECTED_ELEMENT_KEY,
            messageId: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.SELECTED_ELEMENT_KEY,
        },
        {
            key: sessionStorageUtils_1.HOVERED_ELEMENT_KEY,
            messageId: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.HOVERED_ELEMENT_KEY,
        },
    ];
    keysToCheck.forEach(({ key, messageId }) => {
        var _a;
        const elementKey = (0, sessionStorageUtils_1.getMemoryStorageItem)(key);
        const tempoElement = tempoElement_1.TempoElement.fromKey(elementKey);
        if (prevIdToNewIdMap[tempoElement.codebaseId]) {
            const newElement = new tempoElement_1.TempoElement(prevIdToNewIdMap[tempoElement.codebaseId], tempoElement.storyboardId, tempoElement.uniquePath);
            (0, sessionStorageUtils_1.setMemoryStorageItem)(key, newElement.getKey());
            parentPort.postMessage({
                id: messageId,
                elementKey: newElement.getKey(),
                outerHTML: (_a = (0, jquery_1.default)(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${newElement.getKey()}`).get(0)) === null || _a === void 0 ? void 0 : _a.outerHTML,
            });
        }
    });
    // Also update the multiselected element keys
    const multiselectedElementKeys = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.MULTI_SELECTED_ELEMENT_KEYS);
    if (multiselectedElementKeys === null || multiselectedElementKeys === void 0 ? void 0 : multiselectedElementKeys.length) {
        const newMultiselectedElementKeys = [];
        multiselectedElementKeys.forEach((elementKey) => {
            const tempoElement = tempoElement_1.TempoElement.fromKey(elementKey);
            if (prevIdToNewIdMap[tempoElement.codebaseId]) {
                const newElement = new tempoElement_1.TempoElement(prevIdToNewIdMap[tempoElement.codebaseId], tempoElement.storyboardId, tempoElement.uniquePath);
                newMultiselectedElementKeys.push(newElement.getKey());
            }
            else {
                newMultiselectedElementKeys.push(elementKey);
            }
        });
        (0, sessionStorageUtils_1.setMemoryStorageItem)(sessionStorageUtils_1.MULTI_SELECTED_ELEMENT_KEYS, newMultiselectedElementKeys);
        parentPort.postMessage({
            id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.MULTI_SELECTED_ELEMENT_KEYS,
            elementKeys: newMultiselectedElementKeys,
            outerHTMLs: newMultiselectedElementKeys === null || newMultiselectedElementKeys === void 0 ? void 0 : newMultiselectedElementKeys.map((elementKey) => { var _a; return (_a = (0, jquery_1.default)(`.${identifierUtils_1.ELEMENT_KEY_PREFIX}${elementKey}`).get(0)) === null || _a === void 0 ? void 0 : _a.outerHTML; }),
        });
    }
    return Boolean(changes.length);
};
exports.updateCodebaseIds = updateCodebaseIds;
